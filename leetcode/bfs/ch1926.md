## 1926. Nearest Exit from Entrance in Maze

```java
class Solution {
    int[] dicX = {0,0,1,-1};
    int[] dicY = {1,-1,0,0};
    public int nearestExit(char[][] maze, int[] entrance) {
        int exitX = maze[0].length - 1;
        int exitY = maze.length - 1;
        Queue<Point> queue = new LinkedList();

        queue.add(new Point(entrance[1],entrance[0],0));
        maze[entrance[0]][entrance[1]] = '+';

        while(!queue.isEmpty()) {
            Point cur = queue.poll();
            int curX = cur.getX();
            int curY = cur.getY();
            int curCount = cur.getCount();

            for(int i = 0; i < 4; i++) {
                int nextX = curX + dicX[i];
                int nextY = curY + dicY[i];

                if(nextX < 0 || nextX > exitX || nextY < 0 || nextY > exitY) continue;
                if(maze[nextY][nextX]=='+') continue;
                if(isExit(nextX,nextY, entrance,exitX, exitY)) return cur.getCount() + 1;

                maze[nextY][nextX] = '+';

                queue.add(new Point(nextX, nextY, curCount+1));
            }
        }

        return -1;
    }

    private boolean isExit(int pointX,int pointY, int[] entrance, int exitX, int exitY) {

        if(pointX == entrance[1] && pointY == entrance[0]) return false;

        if(pointX == 0) return true;
        if(pointY == 0) return true;
        if(pointX == exitX) return true;
        if(pointY == exitY) return true;

        return false;
    }
}

class Point {
    int x, y;
    int count;

    public Point(int x,int y,int count) {
        this.x = x;
        this.y = y;
        this.count = count;
    }

    public int getX() {
        return this.x;
    }

    public int getY() {
        return this.y;
    }

    public int getCount() {
        return this.count;
    }
}
```
